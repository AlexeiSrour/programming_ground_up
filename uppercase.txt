#PURPOSE:		THIS PROGRAM CONVERTS AN INPUT FILE
#				TO AN OUPUT FILE WITH ALL LETTERS
#				CONVERTED TO UPPERCASE
#
#PROCESSING:	1) OPEN THE INPUT FILE
#				2) OPEN THE OUTPUT FILE
#				3) WHILE WE'RE NOT TAT THE END OF THE INPUT FILE
#					A) READ PART OF FILE INTO OUR MEMORY BUFFER
#					B) GO THROUGH EACH BYTE OF MEMORY
#						IF THE BYTE IS A LOWER-CASE LETTER,
#						CONVERT IT TO UPPERCASE
#					C) WRITE THE MEMORY BUFFER TO OUTPUT FILE

.SECTION .DATA

##### CONSTANTS #####

# SYSTEM CALL NUMBERS
.EQU SYS_OPEN, 5
.EQU SYS_WRITE, 4
.EQU SYS_READ, 3
.EQU SYS_CLOSE, 6
.EQU SYS_EXIT, 1

# OPTIONS FOR SYS_OPEN SYSCALL
.EQU O_RDONLY, 0
.EQU O_CREATE_WRONGLY_TRUNC, 03101

# STANDARD FILE DESCRIPTORS
.EQU STDIN, 0
.EQU STDOUT, 1
.EQU STDERR, 2

# SYSCALL INTERRUPTS
.EQU LINUX_SYSCALL, 0X80
.EQU END_OF_FILE, 0
.EQU NUMBER_ARGUMENTS, 2

.SECTION .BSS
#BUFFER - THIS IS WHERE THE DATA IS LOADED INTO
#			FROM THE DATA FILE AND WRITTEN FROM
#			INTO THE OUTPUT FILE. THIS SHUOLD
#			NEVER EXCEED 16,000 FOR VARIOUS
#			REASONS.
.EQU BUFFER_SIZE, 500
.LCOMM BUFFER_DATA, BUFFER_SIZE

.SECTION .TEXT

#STACK POSITIONS
.EQU ST_SIZE_RESERVE, 8	# 4 BYTES FITS ONE FILE DESCRIPTOR, I.E. THIS MAGIC NUMBER WILL BE USED TO RESERVE ENOUGH SPACE ON STACK FOR FILE DESCIPTORS
.EQU ST_FD_IN, -4
.EQU ST_FD_OUT, -8
.EQU ST_ARGC, 0		# NUMBER OF ARGUMENTS
.EQU ST_ARGV_0, 4	# NAME OF PROGRAM
.EQU ST_ARGV_1, 8	# INPUT FILE NAME
.EQU ST_ARGV_2, 12	# OUTPUT FILE NAME

.GLOBL _START
_START:

# RESERVE SPACE ON STACK FOR FILE DESCRIPTORS
MOVL %ESP, %EBP
SUBL $ST_SIZE_RESERVE, %ESP

# OPENING THE FILES
MOVL $SYS_OPEN, %EAX		# OPEN FILE DESCRIPTOR SYSCALL
MOVL ST_ARGV_1(%EBP), %EBX	# POINTER TO THE FILE NAME
MOVL $O_RDONLY, %ECX		# READ/WRITE/CREATE FLAGS
MOVL $0666, %EDX			# FILE PERMISSIONS, MAGIC NUMBER FOR NOW
INT $LINUX_SYSCALL

MOVL %EAX, ST_FD_IN(%EBP)

MOVL $SYS_OPEN, %EAX		# OPEN FILE DESCRIPTOR SYSCALL
MOVL ST_ARGV_2(%EBP), %EBX	# POINTER TO THE FILE NAME
MOVL $O_CREATE_WRONGLY_TRUNC, %ECX		# READ/WRITE/CREATE FLAGS
MOVL $0666, %EDX			# FILE PERMISSIONS, MAGIC NUMBER FOR NOW
INT $LINUX_SYSCALL

MOVL %EAX, ST_FD_OUT(%EBP)

# BEGIN MAIN LOOP
READ_LOOP_BEGIN:
MOVL $SYS_READ, %EAX
MOVL ST_FD_IN(%EBP), %EBX
MOVL $BUFFER_DATA, %ECX
MOVL $BUFFER_SIZE, %EDX
INT $LINUX_SYSCALL

# CHECK IF END OF FILE REACHED
CMPL $END_OF_FILE, %EAX
JE READ_LOOP_END

# CONVERT BLOCK TO UPPERCASE
PUSHL $BUFFER_DATA
PUSHL %EAX		# %EAX CURRENTLY STORES THE NUMBER OF BYTES PUT INTO BUFFER
CALL CONVERT_TO_UPPER
POPL %EAX		# GET THE SIZE BACK INTO %EAX AFTER FUNCTION CALL (REGISTER WILL HAVE BEEN THRASHED DURING FUNCTION CALL)
ADDL $4, %ESP

# WRITE THE BLOCK OUT TO THE OUTPUT FILE
MOVL %EAX, %EDX			# SINCE %EAX CURRENTLY HOLDS THE SIZE OF THE BUFFER IN BYTES AND WE'LL BE REPLACING IT SOON
MOVL $SYS_WRITE, %EAX
MOVL ST_FD_OUT(%EBP), %EBX
MOVL $BUFFER_DATA, %ECX
INT $LINUX_SYSCALL

# RESTART THE LOOP
JMP READ_LOOP_BEGIN

READ_LOOP_END:

# CLOSE THE FILE DESCRIPTORS
MOVL $SYS_CLOSE, %EAX
MOVL ST_FD_OUT(%EBP), %EBX
INT $LINUX_SYSCALL

MOVL $SYS_CLOSE, %EAX
MOVL ST_FD_IN(%EBP), %EBX
INT $LINUX_SYSCALL

# RESTORE THE STACK?
MOVL %EBP, %ESP
POPL %EBP

# EXIT
MOVL $SYS_EXIT, %EAX
MOVL $0, %EBX
INT $LINUX_SYSCALL

#PURPOSE:	THIS FUNCTION ACUALLY DOES THE
#			CONVERSION TO UPPER CASE FOR A BLOCK
#
#INPUT:		THE FIRST PARAMETER IS THE LOCATION
#			OF THE BLOCK OF MEMORY TO CONVERT
#			THE SECOND PARAMETER IS THE LENGTH
#			OF THAT BUFFER IN BYTES
#
#OUTPUT:	THIS FUNCTION OVERWRITES THE CURRENT
#			BUFFER WITHT HE UPPER -CASIFIED VERSION.
#
#VARIABLES:	%EAX - BEGINNING OF THE BUFFER
#			%EBX - LENGTH OF THE BUFFER
#			%EDI - CURRENT BUFFER OFFSET
#			%CL - CURRENT BYTE BEING EXAMINED
#				(LOWER BYTE OF %ECX -> %CH, %CL) (LIKE HOW EAX CAN BE SPLIT INTO AH AND AL)

### CONSTANTS ###
.EQU LOWER_CASE_A, 'A'
.EQU LOWER_CASE_Z, 'Z'
.EQU UPPER_CONVERSION, 'A' - 'A'

### STACK STUFFS(?) ###
.EQU ST_BUFFER_LEN, 8	# LENGTH OF THE BUFFER
.EQU ST_BUFFER, 12		# ACTUAL BUFFER

.TYPE CONVERT_TO_UPPER @FUNCTION
CONVERT_TO_UPPER:
PUSHL %EBP
MOVL %ESP, %EBP

MOVL ST_BUFFER(%EBP), %EAX
MOVL ST_BUFFER_LEN(%EBP), %EBX
MOVL $0, %EDI

# IF A BUFFER OF 0 SIZE HAS BEEN GIVEN, JUST LEAVE
CMPL $0, %EBX
JE CONVERT_LOOP_END

# OTHERWISE, BEGIN THE FUNCTION
CONVERT_LOOP:
MOVB (%EAX,%EDI,1), %CL			# LOAD THE CURRENT BYTE

CMPB $LOWER_CASE_A, %CL			# COMPARE IF IT COMES AFTER LETTER 'A'
JL INCREMENT_AND_RELOOP			# IF NOT, MOVE ON TO NEXT BYTE, OTHERWISE FALL THROUGH

CMPB $LOWER_CASE_Z, %CL			# COMPARE IF IT COMES BEFORE LETTER 'Z'
JG INCREMENT_AND_RELOOP			# IF NOT, MOVE ON TO NEXT BYTE, OTHERWISE FALL THROUGH

ADDB $UPPER_CONVERSION, %CL		# BYTE MUST BE BETWEEN A-Z, THEREFORE ADD CONSTANT TO MAKE IT A-Z
MOVB %CL, (%EAX,%EDI,1)			# WRITE IT BACK TO THE BUFFER

INCREMENT_AND_RELOOP:
INCL %EDI						# INCREMENT TO THE NEXT BYTE
CMPL %EDI, %EBX					# CHECK TO MAKE SURE END OF BUFFER HASN'T BEEN REACHED
JNE CONVERT_LOOP				# RESTART THE LOOP AS LONG AS BYTES REMAIN

CONVERT_LOOP_END:
MOVL %EBP, %ESP
POPL %EBP
RET
