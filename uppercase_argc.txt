# PURPOSE: THIS PROGRAM IS THE VERY LAST EXERCISE FROM CHAPTER 5. IT WILL EITHER PRINT OUT TO STDOUT OR
# A SEPARATELY SPECIFIED FILE DEPENDING ON NUMBER OF ARGUEMENTS PASSED IN

.SECTION .DATA

INPUT_OPEN_FAILED_MSG:
.ASCII "FAILED TO OPEN PROVIDED INPUT FILE, HAS THERE BEEN A MISPELLING?\N"
.EQU INPUT_OPEN_FAILED_MSG_LEN, . - INPUT_OPEN_FAILED_MSG

OUTPUT_OPEN_FAILED_MSG:
.ASCII "FAILED TO OPEN PROVIDED OUTPUT FILE...IDK HOW THIS WOULD BE POSSIBLE? CHECK ERROR CODE AND GOOGLE\N"
.EQU OUTPUT_OPEN_FAILED_MSG_LEN, . - OUTPUT_OPEN_FAILED_MSG

TOO_MANY_ARGUMENTS_ERROR_MSG:
.ASCII "TOO MANY ARGUMENTS HAVE BEEN PROVIDED TO THE PROGRAM\N"
.EQU TOO_MANY_ARGUMENTS_ERROR_MSG_LEN, . - TOO_MANY_ARGUMENTS_ERROR_MSG

USAGE_STRING:
.ASCII "USAGE IS <PROGRAM NAME> [INPUT FILE NAME] [OUTPUT FILE NAME]\N"
.EQU USAGE_STRING_LEN, . - USAGE_STRING

INPUT_READ_FAILED_MSG:
.ASCII "FAILED TO READ IN STREAM FROM INPUT FILE\N"
.EQU INPUT_READ_FAILED_MSG_LEN, . - INPUT_READ_FAILED_MSG

OUTPUT_WRITE_FAILED_MSG:
.ASCII "FAILED TO WRITE TO OUTPUT FILE\N"
.EQU OUTPUT_WRITE_FAILED_MSG_LEN, . - OUTPUT_WRITE_FAILED_MSG

.SECTION .BSS

.EQU BUFFER_SIZE, 500
.LCOMM BUFFER_DATA, BUFFER_SIZE

.SECTION .TEXT

# LINUX SYSCALLS
.EQU SYS_EXIT, 1
.EQU SYS_READ, 3
.EQU SYS_WRITE, 4
.EQU SYS_OPEN, 5
.EQU SYS_CLOSE, 6

.EQU LINUX_SYSCALL, 0X80

# OPTIONS (ARGUMENT 3) FOR OPEN SYSCALL
.EQU O_RDONLY, 0
.EQU O_CREATE_WRONGLY_TRUNCATE, 03101	# I.E. CREATE FILE IF IT ISN'T THERE, AND NOT TO APPEND BUT WIPE FILE CLEAN

.EQU STDIN, 0
.EQU STDOUT, 1
.EQU STDERR, 2

.EQU ST_ARGC, 4
.EQU ST_ARGV_0, 8	# THIS IS THE NAME OF THE EXECUTABLE
.EQU ST_ARGV_1, 12	# THIS WILL BE THE ARGUMENT TO THE INPUT FILE (IF PROVIDED)
.EQU ST_ARGV_2, 16	# THIS WILL BE THE ARGUMENT TO THE OUTPUT FILE (IF PROVIDED)

.EQU ST_LOCAL_STORAGE, 12	# ENOUGH ROOM TO STACK ALLOCATE INPUT AND OUTPUT FILE DESCRIPTORS
.EQU ST_FD_IN, -4
.EQU ST_FD_OUT, -8
.EQU ST_ERROR_CODE, -12
.EQU ST_BYTES_READ, -12	# ERROR CODE AND WRITTEN BYTES ARE ALIASED

.GLOBL _START
_START:
PUSHL %EBP
MOVL %ESP, %EBP
SUBL $ST_LOCAL_STORAGE, %ESP	# ALLOCATING SPACE FOR INPUT FILE DESCRIPTOR AND OUTPUT FILE DESCRIPTOR

MOVL ST_ARGC(%EBP), %EAX
CMPL $1, %EAX					# CHECK IF NO EXTRA ARGUEMENTS PROVIDED
JNE ARGUMENTS_CHECK_2

MOVL $STDIN, ST_FD_IN(%EBP)		# MAKE INPUT AND OUTPUT THE CONSOLE
MOVL $STDOUT, ST_FD_OUT(%EBP)
JMP ARGUMENT_CHECK_END

ARGUMENTS_CHECK_2:
CMPL $2, %EAX					# CHECK IF AN INPUT FILE HAS BEEN PROVIDED
JNE ARGUMENTS_CHECK_3

# OPEN A FILE DESCIPTOR FOR THE INPUT FILE AND CHECK FOR SUCCESS
MOVL $SYS_OPEN, %EAX
MOVL ST_ARGV_1(%EBP), %EBX
MOVL $O_RDONLY, %ECX
MOVL $0666, %EDX				# MAGIC NUMBER FOR FULL READ/WRITE/EXECUTE PERMISSION ON FILE, I THINK

INT $LINUX_SYSCALL

#CHECK FOR ERROR OR SUCCESS
CMPL $0, %EAX
JGE INPUTFILE_OPENED_SUCCESSFULLY

# ON ERROR, PRINT OUT ERROR MESSAGE AND CLOSE PROGRAM
MOVL %EAX, ST_ERROR_CODE(%EBP)	# SAVE THE ERROR CODE TO STACK FOR LATER USE
MOVL $SYS_WRITE, %EAX
MOVL $STDERR, %EBX
MOVL $INPUT_OPEN_FAILED_MSG, %ECX
MOVL $INPUT_OPEN_FAILED_MSG_LEN, %EDX

INT $LINUX_SYSCALL

MOVL ST_ERROR_CODE(%EBP), %EBX	# WILL BE RETURNING THE ERROR CODE ON PROGRAM EXIT
JMP END_PROGRAM

INPUTFILE_OPENED_SUCCESSFULLY:
MOVL %EAX, ST_FD_IN(%EBP)		# SAVE IN THE INPUT FILE TO THE STACK
MOVL $STDOUT, ST_FD_OUT(%EBP)	# PUT THE OUTPUT FILE AS BEING STDOUT
JMP ARGUMENT_CHECK_END

ARGUMENTS_CHECK_3:
CMPL $3, %EAX
JNE ARGUMENTS_ERROR	

# OPEN A FILE DESCIPTOR FOR THE INPUT FILE AND CHECK FOR SUCCESS
MOVL $SYS_OPEN, %EAX
MOVL ST_ARGV_1(%EBP), %EBX
MOVL $O_RDONLY, %ECX
MOVL $0666, %EDX				# MAGIC NUMBER FOR FULL READ/WRITE/EXECUTE PERMISSION ON FILE, I THINK

INT $LINUX_SYSCALL

#CHECK FOR ERROR OR SUCCESS
CMPL $0, %EAX
JGE ARGUMENT_CONTINUE_CHECK_3

# ON ERROR, PRINT OUT ERROR MESSAGE AND CLOSE PROGRAM
MOVL %EAX, ST_ERROR_CODE(%EBP)	# SAVE THE ERROR CODE TO STACK FOR LATER USE
MOVL $SYS_WRITE, %EAX
MOVL $STDERR, %EBX
MOVL $INPUT_OPEN_FAILED_MSG, %ECX
MOVL $INPUT_OPEN_FAILED_MSG_LEN, %EDX

INT $LINUX_SYSCALL

MOVL ST_ERROR_CODE(%EBP), %EBX	# WILL BE RETURNING THE ERROR CODE ON PROGRAM EXIT
JMP END_PROGRAM

ARGUMENT_CONTINUE_CHECK_3:
# OPEN A FILE DESCIPTOR FOR THE OUTPUT AND CHECK FOR SUCCESS
MOVL %EAX, ST_FD_IN(%EBP)		# SAVE CURRENT INPUT DESCRIPTOR
MOVL $SYS_OPEN, %EAX
MOVL ST_ARGV_2(%EBP), %EBX
MOVL $O_CREATE_WRONGLY_TRUNCATE, %ECX
MOVL $0666, %EDX				# MAGIC NUMBER FOR FULL READ/WRITE/EXECUTE PERMISSION ON FILE, I THINK

INT $LINUX_SYSCALL

#CHECK FOR ERROR OR SUCCESS
CMPL $0, %EAX
JGE OUTPUTFILE_OPENED_SUCCESSFULLY

# ON ERROR, PRINT OUT ERROR MESSAGE AND CLOSE PROGRAM
MOVL %EAX, ST_ERROR_CODE(%EBP)	# SAVE THE ERROR CODE TO STACK FOR LATER USE
MOVL $SYS_WRITE, %EAX
MOVL $STDERR, %EBX
MOVL $OUTPUT_OPEN_FAILED_MSG, %ECX
MOVL $OUTPUT_OPEN_FAILED_MSG_LEN, %EDX

INT $LINUX_SYSCALL

MOVL ST_ERROR_CODE(%EBP), %EBX	# WILL BE RETURNING THE ERROR CODE ON PROGRAM EXIT
JMP END_PROGRAM

OUTPUTFILE_OPENED_SUCCESSFULLY:
MOVL %EAX, ST_FD_OUT(%EBP)		# SAVE OUTPUT TO THE STACK (INPUT ALREADY THERE)
JMP ARGUMENT_CHECK_END

ARGUMENTS_ERROR:
# WRITE TO STDOUT THAT TOO MANY ARGUMENTS HAVE BEEN PROVIDED (AND THE USAGE STRING TOO)

MOVL $SYS_WRITE, %EAX
MOVL $STDOUT, %EBX
MOVL $TOO_MANY_ARGUMENTS_ERROR_MSG, %ECX
MOVL $TOO_MANY_ARGUMENTS_ERROR_MSG_LEN, %EDX

INT $LINUX_SYSCALL

MOVL $SYS_WRITE, %EAX
MOVL $STDOUT, %EBX
MOVL $USAGE_STRING, %ECX
MOVL $USAGE_STRING_LEN, %EDX

INT $LINUX_SYSCALL

MOVL $-1, %EBX
JMP END_PROGRAM

ARGUMENT_CHECK_END:
# BY THIS POINT IN THE PROGRAM, WE HAVE FULLY VALIDATED THAT ALL FILE DESCRIPTORS ARE OPEN AND READY TO GO
# AT THIS POINT, WE ARE TO READ IN TO A BUFFER FROM INPUT, CAPITALISE THE BUFFER, THEN WRITE TO THE OUTPUT FROM BUFFER
# ADDITIONAL ERROR CHECKS WILL HAVE TO BE PERFORMED DURING READING AND WRITING

# READ THE INPUT INTO THE BUFFER
MOVL $SYS_READ, %EAX
MOVL ST_FD_IN(%EBP), %EBX
MOVL $BUFFER_DATA, %ECX
MOVL $BUFFER_SIZE, %EDX

INT $LINUX_SYSCALL

# ERROR CHECKING
CMPL $0, %EAX
JE END_PROGRAM_SUCCESS  # WE'VE REACHED INPUT END, TIME TO CLOSE THE PROGRAM
JG CONTINUE_WRITING		# NO ERROR, SO CONTINUE TO NEXT PHASE

MOVL %EAX, ST_ERROR_CODE(%EBP)
MOVL $SYS_WRITE, %EAX
MOVL $STDERR, %EBX
MOVL $INPUT_READ_FAILED_MSG, %ECX
MOVL $INPUT_READ_FAILED_MSG_LEN, %EDX

INT $LINUX_SYSCALL

JMP END_PROGRAM

CONTINUE_WRITING:
# TIME TO CAPITALISE THE BUFFER
PUSHL %EAX
PUSHL $BUFFER_DATA
CALL TO_UPPER
ADDL $4, %ESP
POPL %EAX				# RESTORE LENGTH OF BUFFER INTO %EAX

# TIME TO WRITE OUT OUR DATA TO THE OUTPUT
WRITING_LOOP:			# LABEL HERE IN CASE THE FULL WRITE DOESN'T COMPLETE
MOVL %EAX, ST_BYTES_READ(%EBP)	# SAVE TOTAL READ BYTES TO THE STACK FOR LATER USAGE
MOVL %EAX, %EDX			# TOTAL READ IS CURRENTLY HELD IN %EAX
MOVL $SYS_WRITE, %EAX
MOVL ST_FD_OUT(%EBP), %EBX
MOVL $BUFFER_DATA, %ECX

INT $LINUX_SYSCALL

CMPL $0, %EAX
JGE VALIDATE_WRITE_COMPLETED

MOVL %EAX, ST_ERROR_CODE(%EBP)
MOVL $SYS_WRITE, %EAX
MOVL $STDERR, %EBX
MOVL $OUTPUT_WRITE_FAILED_MSG, %ECX
MOVL $OUTPUT_WRITE_FAILED_MSG_LEN, %EDX

INT $LINUX_SYSCALL

MOVL ST_ERROR_CODE(%EBP), %EAX
JMP END_PROGRAM


VALIDATE_WRITE_COMPLETED:
CMPL ST_BYTES_READ(%EBP), %EAX
JE ARGUMENT_CHECK_END	# TIME TO LOOP OVER AGAIN AND REREAD THE NEXT SECTION

SUBL ST_BYTES_READ(%EBP), %EAX	# %EAX HOLDS THE REMAININD NUMBER OF BYTES TO BE READ
JMP WRITING_LOOP

END_PROGRAM_SUCCESS:
#CLEAN UP AND CLOSE THE PROGRAM WITH A SUCCESS CODE (0)
MOVL $SYS_CLOSE, %EAX
MOVL ST_FD_OUT(%EBP), %EBX
INT $LINUX_SYSCALL

MOVL $SYS_CLOSE, %EAX
MOVL ST_FD_IN(%EBP), %EBX
INT $LINUX_SYSCALL

MOVL $0, %EBX

END_PROGRAM:	# LABEL FOR ALL OTHER EMERGENCY CLOSES SUCH AS CRITICAL ERRORS
MOVL %EBP, %ESP
POPL %EBP

MOVL $SYS_EXIT, %EAX
INT $LINUX_SYSCALL


.EQU ST_BUFFER_DATA, 8	# FIRST PARAMETER IS A POINTER TO THE BUFFER TO CAPITALISE
.EQU ST_BUFFER_LEN, 12	# SECOND PARAMETER IS THE LENGTH OF THE BUFFER
.EQU UPPER_CONVERSION_CONST, 'A' - 'A'	# ADD THIS CONSTANT TO ANY LOWERCASE LETTER TO TURN IT UPPERCASE
.EQU LOWER_CASE_BOTTOM, 'A'
.EQU LOWER_CASE_UPPER, 'Z'
.TYPE TO_UPPER @FUNCTION
TO_UPPER:
PUSHL %EBP
MOVL %ESP, %EBP

MOVL ST_BUFFER_DATA(%EBP), %ECX	# WILL HOLD THE OFFSET
MOVL ST_BUFFER_LEN(%EBP), %EDX
MOVL $0, %EAX			# ZEROING OUT EAX AS THE LOWER PORTION WILL HOLD OUR BUFFER

CONVERSION_LOOP:
CMPL $0, %EDX
JE CONVERSION_LOOP_END	# FINISHED READING THROUGH THE BUFFER
DECL %EDX
MOVB (%ECX,%EDX,1), %AL	# AL WILL HOLD THE CURRENT BYTE (I.E. LETTER)

CMP $LOWER_CASE_BOTTOM, %AL
JL CONVERSION_LOOP		# IS NOT LOWER CASE LETTER, CAN READ IN NEXT LETTER

CMP $LOWER_CASE_UPPER, %AL
JG CONVERSION_LOOP		# IS NOT LOWER CASE LETTER, CAN READ IN NEXT LETTER

ADDB $UPPER_CONVERSION_CONST, %AL	# CONVERT LETTER TO UPPER CASE
MOVB %AL, (%ECX,%EDX,1)				# THEN WRITE IT BACK INTO THE BUFFER
JMP CONVERSION_LOOP

CONVERSION_LOOP_END:

MOVL %EBP, %ESP
POPL %EBP
RET
